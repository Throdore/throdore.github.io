<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>创业可能会遇到什么事？某群某动化讲座笔记</title>
    <link href="/2022/08/19/%E5%88%9B%E4%B8%9A%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F%E6%9F%90%E7%BE%A4%E6%9F%90%E5%8A%A8%E5%8C%96%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/19/%E5%88%9B%E4%B8%9A%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F%E6%9F%90%E7%BE%A4%E6%9F%90%E5%8A%A8%E5%8C%96%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="0x01-人生的借鉴"><a href="#0x01-人生的借鉴" class="headerlink" title="0x01 人生的借鉴"></a>0x01 人生的借鉴</h3><p>最近眼睛比较难受，更新比较慢。十一年创业经历的故事，人生的借鉴。2010年，不希望做老师，二十岁看到未来三十年的路，被李老师忽悠来创业，一开始，有钱，但不知道做什么。第一步：去各种地方，探讨可以做点什么，很多人说可以做这个，做需求量大的设备，做工业机器人，被忽悠的创业，项目也是拍脑袋的。</p><p>两天两夜，机器人的行业研究，把所有机器人公司，年报，市场研究报告，提取了很多的讯息，对于未来的预测，数学模型，第一老龄化，第二 人会转向社会服务行业，机器人变为工业刚需，大的需求，松山湖，桌椅板凳都无，去了才买电脑，买桌椅板凳，刚开始就单纯想做机器人，刚开始，工程机械的焊接，调研相关企业，发现没有机器人在焊接，买机器人，开始做。招销售（调研企业的亲戚子弟），招标，注册资金要求500万，中间人获利，前期只给30%，大厂做不了，换小的创业生意。焊板筋，说机器人多好多好，有各种好处，试试吧？听到专家意见，说很难。所以就没再干。东找西找，2011年10月份，遇到大忽悠，无知无畏，签协议，一起出资，各一半，买日本设备，他们负责抄，抄完卖出去。然后开始卖抄完的设备，大忽悠说可以挣钱，全公司很开心，可是设备进现场，很多预期功能，做不到。结果：自己垫进去40万，一分钱都没拿到。2013年，激烈的讨论，这帮人到底要干嘛？学生，没有产业经验，不应该去做项目，回归做产品，迭代基础，找路的故事。</p><h3 id="0x02-开始做机器人产品线"><a href="#0x02-开始做机器人产品线" class="headerlink" title="0x02 开始做机器人产品线"></a>0x02 开始做机器人产品线</h3><p>开始做机器人，调研食品包装，烘培食品，找做月饼的企业，也有意愿做产业升级，追到了自己的第一个客户，当时只想卖机器人，遇到第二个大忽悠，先给钱去做产线，结果被骗钱，认栽？退钱给客户？自己重新做月饼线，又遇到各种各样的问题，整个月饼线，做了3年半，只挣了少部分钱，熬走了很多的工程师。当自己啃下来这个生产线的时候，就检验了自己的能力。看当下，做你应该做的事，花了时间绕开了，等于白花。花了时间，奠定了发展和企业的自信心。</p><p>2018年，宁德新能源，进入了宁德新时代机器人供应链名单，给买了300台机器人。</p><p>智能不是开发出来的，智能是学习出来的，遭受到质疑，事情朝着好像能做出来方向去发展。8年的时间，中小企业，期待使用更智能，8年时间打造一个操作系统，领先市场起码5年时间，拒绝特斯拉的订单，6-8个月对于未来的业务无任何的帮助，团队理解的问题。</p><p>工业机器人减速机，日本人垄断，中国团队做，一个问题：从正向设计的理念来谈一下为什么设计这个？客户最怕的是出了问题，改正不了，不知道从哪里解决。主打价格，不是正确的选择。照着抄，便宜，还有钱，我就要和你做生意？</p><h3 id="0x03-学会懂事"><a href="#0x03-学会懂事" class="headerlink" title="0x03 学会懂事"></a>0x03 学会懂事</h3><p>首先要学会懂事，别人骗你就是别人的错？往往把别人想成是自己想象的样子，当把握不深的时候，就会想一切想做他的理由，当你认为一个人是坏人，他做什么事都是坏人。没有人是雷锋，是自己对于事物没有做任何的预期和准备和防范。人生该掉的坑，一个人都不会少。躺平不难，其他都挺难的，难要怎么看？正确与否是由历史来说的。每个人的所有决定，都是自己做的。创业没有一蹴而就，就是走向社会的形式，只是你们选择用怎么样的形式去让自己成长。</p><h3 id="0x04-不要考虑太远的技术"><a href="#0x04-不要考虑太远的技术" class="headerlink" title="0x04 不要考虑太远的技术"></a>0x04 不要考虑太远的技术</h3><p>存在缺工，但是还有很多学生无工作。培养这么多年，不可能回去当工人。广东普工的成本是7000块钱，山东，也是。贵州6000块。基本社会的普工。先要做物理世界的问题，在考虑元宇宙的问题。为什么波士顿动力的机械狗，没有大规模应用？讲智能，是如何让他进化，载体不是配技术和工程师，应该是真正使用的人。把技术神化成了产品。很多时候，刚刚好是最好的产品。</p><p>b端消费心理：1、划算（买了觉得值）2、安全，</p><p>初创团队，分工，同时成长。顺人性。就是解决人的问题，只是复杂度不太一样而已。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>“访谈的技巧”</title>
    <link href="/2022/08/11/%E2%80%9C%E8%AE%BF%E8%B0%88%E7%9A%84%E6%8A%80%E5%B7%A7%E2%80%9D/"/>
    <url>/2022/08/11/%E2%80%9C%E8%AE%BF%E8%B0%88%E7%9A%84%E6%8A%80%E5%B7%A7%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="如何让别人愿意说话？"><a href="#如何让别人愿意说话？" class="headerlink" title="如何让别人愿意说话？"></a>如何让别人愿意说话？</h2><p>（自我思考）今天晚上有幸听到了于老师的讲座：访谈类的，其中谈到的很多的知识点，很类似于当年看过的一本黑客书籍《社会工程-安全体系中的人性漏洞》，以下为于盈老师讲座的重点，作为一些归纳，以待日后来看。</p><ul><li>决策 信息就是一切</li><li>用信息提升自己的价值</li></ul><h3 id="访谈：事前、事中、事后"><a href="#访谈：事前、事中、事后" class="headerlink" title="访谈：事前、事中、事后"></a>访谈：事前、事中、事后</h3><ul><li><p>做功课 采访前做好功课，了解访谈嘉宾的背景和相关信息（过往的新闻，看法，故事，经历）</p></li><li><p>热身、打开话题（闲聊：表示对他人的关心，建立对话的基础，称赞认可：称赞、认可、肯定对方近期的发展，拉近距离：谈论共同的朋友或你们共同认识的令人尊敬的人，看法交流：对基本食物看法的交流。比如对于大家&#x2F;未来的趋势发展交换意见）、</p></li><li><p>专业的访谈内容：保持对话和讨论专业性，建立可信度，在提出更多个人&#x2F;生活的问题。</p></li><li><p>访谈是对话，不是一问一答。（类似于打乒乓球，很愉快。）罗列所有的提纲，访谈前，全部OK</p></li><li><p>用户访谈“最”的问题，最欣赏&#x2F;最欣赏&#x2F;记忆最深、最不满意&#x2F;最讨厌、感到最受鼓励&#x2F;感到情绪最低落的……问多些“为什么？怎么样？”越细的问题，越多的料。开放性的问题。</p></li><li><p>行为观察，根据行为，观察可能的潜台词。</p><p>​示例：询问孩子的鞋子。分享一些关于你自己的事情-你的心情等。为什么摆放这个东西？）</p><p>​制定目标-了解受访者&#x3D;访谈提纲-背景介绍-热身问题-访谈-</p><p>​利用一些工具进行总结。</p></li><li><p>原则一：初学者心态</p></li><li><p>原则二：多听少讲（自我放到一边，关注你周围人的痛点，需求和意见，倾听，学习，不是教育、打动、说服被访人）</p></li><li><p>原则三：聚焦事实、而非观点</p></li><li><p>原则四：多问为什么？</p></li><li><p>原则六：延迟判断。</p></li><li><p>原则七：就算不认可，不要直接否定（问多几个为什么）</p></li><li><p>原则八：访谈是为了学习，而不是为了验证购买企图。</p></li><li><p>不要过早提及你脑海中的解决方案。（不要解释，这款产品是干什么的，可以问现有的产品有没有解决你的问题。）</p></li><li><p>开放性的</p></li></ul><h3 id="访谈小技巧"><a href="#访谈小技巧" class="headerlink" title="访谈小技巧"></a>访谈小技巧</h3><ul><li>有力的握手</li><li>眼神的交流，表情，点头，身体前倾，头侧收下吧，不要交叉手。保持距离，笑容。</li><li>放慢一点语速，放低一点声音，留白</li><li>递纸巾，口香糖，零食等</li><li>反问，重复别人说过的话</li><li>设置交流市场。</li></ul><h3 id="Don‘s"><a href="#Don‘s" class="headerlink" title="Don‘s"></a>Don‘s</h3><ul><li>眼神游离，翻白眼、不屑的眼光，摸耳朵等。</li></ul><h3 id="表达感谢"><a href="#表达感谢" class="headerlink" title="表达感谢"></a>表达感谢</h3><p>写一封一定篇幅的感谢信、手写卡、真香的赞扬、寄送小礼物等。电子时代-纸质的东西拿到是特别惊喜的。细节，不放弃，用心尝试去做，打动人心。</p><h3 id="分享笔记"><a href="#分享笔记" class="headerlink" title="分享笔记"></a>分享笔记</h3><ul><li>整理信息的小工具，归档，便于寻找；说明你在认真倾听和学习到许多。</li><li>有效的信息的分享，保留介质的信息。</li></ul><h3 id="如何表达，让别人愿意帮你？"><a href="#如何表达，让别人愿意帮你？" class="headerlink" title="如何表达，让别人愿意帮你？"></a>如何表达，让别人愿意帮你？</h3><h5 id="如何建立关系，发展mentor"><a href="#如何建立关系，发展mentor" class="headerlink" title="如何建立关系，发展mentor"></a>如何建立关系，发展mentor</h5><ul><li>把自己变成一个有意思的人，有价值的人。(读书、对社会发展、行业趋势、国家发展等看法的交流，信息获取与整理。)</li><li>专业性——发表一些见解，发些个人故事</li><li>论坛上&#x2F;活动上勇于发言</li><li>乐于提供协助，不要势力，不怕吃亏。</li><li>李老师理念：看马不如溜马。（有相关故事）</li><li>平时的积累，建立自己的声名。</li><li>主动帮忙，不求回报。先贡献自己的力量，优先Yes.</li><li>做个不吝啬分享的，帮人和做事靠谱的人。</li></ul><h4 id="发展洞见"><a href="#发展洞见" class="headerlink" title="发展洞见"></a>发展洞见</h4><p>看到大家都看到的，但能够发泄其他人发现不了的。带着一双好奇的眼睛看世界！</p><ul><li>行为观察 （通常无法直接告诉你如何进行颠覆性创新，但可以花一天时间和他们去了解）</li><li>青少年推动</li></ul><p>（自我思考）讲到凯文凯利的故事的时候，其中有一条是凯文凯利会去关注灰色地带的技术和发展。众所周知网络安全这个行业，其实就是从黑客的角度去剖析网络安全的防护技术（未知攻，焉知防？）。这正是凯文凯利提到的灰色地带技术的反向发展和围堵。</p><h4 id="如何建立信任？"><a href="#如何建立信任？" class="headerlink" title="如何建立信任？"></a>如何建立信任？</h4><p>什么是信任？人品+能力+做事情的方式。</p><p>长期主义、诚信第一、</p><p>尊重承诺、勇于认错、</p><p>清晰沟通、学会示弱、</p><p>热心助人、关心他人、</p><p>坚持对的、坦诚分享。</p><p>杜绝心胸狭隘，见不得别人好。身边的人好，你也好了。给自己留多一些后路，抱着长期的态度。朋友之间不是一笔买卖。团队之间，建立信任。团建，团队沟通，建立感情，信任。</p><h4 id="怎么拓展人脉"><a href="#怎么拓展人脉" class="headerlink" title="怎么拓展人脉"></a>怎么拓展人脉</h4><p>组织一些自创的活动。发展自己辅导的对象。慈善活动，志愿者，主动出击，保持联系，人脉需要梳理，不要八卦、消极、找借口。参加各类论坛，先做功课，了解大佬个人的信息。各种机会，交流，了解。</p><p>（以色列创业教父）最值钱的资产：梳理各类人际关系资产。人脉资产，认识的人的人，各种人物的画像。没有人喜欢整天抱怨的人，任何人都有自己面临的困难和挑战。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu部署Carla仿真器</title>
    <link href="/2022/08/03/Ubuntu%E9%83%A8%E7%BD%B2Carla%E4%BB%BF%E7%9C%9F%E5%99%A8/"/>
    <url>/2022/08/03/Ubuntu%E9%83%A8%E7%BD%B2Carla%E4%BB%BF%E7%9C%9F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-Carla简介"><a href="#0x01-Carla简介" class="headerlink" title="0x01 Carla简介"></a>0x01 Carla简介</h2><p>CARLA 是一个用于自动驾驶研究的开源模拟器。CARLA 从头开始开发，以支持自动驾驶系统的开发、培训和验证。除了开源代码和协议外，CARLA 还提供开放的数字资产（城市布局、建筑、车辆），这些资产是为此目的而创建的，可以自由使用。仿真平台支持对传感器套件和环境条件的灵活规范。目前最新的版本是0.9.13版本，具体细节可以参考一下目前发布于bilibili的视频。</p><p><a href="https://www.bilibili.com/video/BV1PJ411W7pf?spm_id_from=333.337.search-card.all.click&amp;vd_source=4778043b67930a145afa638b83f65423">https://www.bilibili.com/video/BV1PJ411W7pf?spm_id_from=333.337.search-card.all.click&amp;vd_source=4778043b67930a145afa638b83f65423</a></p><p>值得一提的是，最早我采用的模拟器是LGSVL，因为其和Apollo6.0版本可以进行联合虚拟仿真，且目前网络资料较多，但是很不幸的是LGSVL停止了更新，最后的版本截止到了2020版，并且官网在2022年6月之后将不能保证一直开放。而Kevin师傅他们实验室目前所使用的虚拟仿真系统是基于Carla搭建的，在搭配罗技的方向盘，简直就是“侠盗猎车”炫酷感。除此之外，Carla支持ROS接口，这就意味着通过ROS的包，或许可以做更多属于未来的事情。</p><h2 id="0x02-突出特点"><a href="#0x02-突出特点" class="headerlink" title="0x02 突出特点"></a>0x02 突出特点</h2><ul><li><strong>通过服务器多客户端架构实现可扩展性</strong>：同一或不同节点中的多个客户端可以控制不同的参与者。</li><li><strong>灵活的 API</strong>：CARLA 公开了一个强大的 API，允许用户控制与模拟相关的所有方面，包括交通生成、行人行为、天气、传感器等等。</li><li><strong>自动驾驶传感器套件</strong>：用户可以配置多种传感器套件，包括激光雷达、多摄像头、深度传感器和 GPS 等。</li><li><strong>规划和控制的快速模拟</strong>：此模式禁用渲染以提供不需要图形的交通模拟和道路行为的快速执行。</li><li><strong>地图生成：用户可以通过</strong><a href="https://www.vectorzero.io/">RoadRunner等工具轻松地按照</a><a href="http://www.opendrive.org/">OpenDrive</a>标准创建自己的地图。</li><li><strong>交通场景模拟</strong>：我们的引擎<a href="https://github.com/carla-simulator/scenario_runner">ScenarioRunner</a>允许用户根据模块化行为定义和执行不同的交通场景。</li><li><strong>ROS 集成</strong>：CARLA通过我们的<a href="https://github.com/carla-simulator/ros-bridge">ROS 桥</a>提供与<a href="http://www.ros.org/">ROS的集成</a></li><li><strong>自动驾驶基线</strong>：我们提供自动驾驶基线作为 CARLA 中的可运行代理，包括<a href="https://github.com/carla-simulator/carla-autoware">AutoWare</a>代理和<a href="https://github.com/felipecode/coiltraine">条件模仿学习</a>代理。</li></ul><p>相关的一些会谈可以参考Carla官网：<a href="http://carla.org/">http://carla.org/</a></p><h2 id="0x03-系统配置要求"><a href="#0x03-系统配置要求" class="headerlink" title="0x03 系统配置要求"></a>0x03 系统配置要求</h2><ul><li>Ubuntu 18.04(18之前的系统已经逐步淘汰了，安装个GNUradio都需要18以上的版本了)，Ubuntu 20.04也可以部署Carla, 不过我本人不建议使用该版本。</li><li>Nvidia Drvier 提前安装好，并且电脑配置一个至少3G的GPU.</li><li>网络连接良好</li><li>硬盘里至少预存100G空间</li></ul><p>事实上目前我所用的ARM架构的电脑是不能部署Carla的，为此我想了很多的办法，第一个办法是基于搭载英伟达的服务器去进行部署，众所周知，这类虚拟仿真软件都是非常依赖强大的图形处理能力，看了下价格，，果断放弃。比我每月590RMB的服务器还要贵，第二种办法就是把我已经退休一年的雷神911air重新搬上历史的舞台，使得我在暑期的这一个月有的玩Carla。那在解决了这些问题之后，我就开始在我的退休电脑上来安装Carla了。我觉得叫他卡拉更舒服，哈哈哈哈～</p><h2 id="0x04-部署Carla"><a href="#0x04-部署Carla" class="headerlink" title="0x04 部署Carla"></a>0x04 部署Carla</h2><p>第一件事情是去部署安装 NVIDIA GPU 驱动，安装如下(Ubuntu18)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt-get update<br>sudo apt-add-repository multiverse<br>sudo apt-get update<br>sudo apt-get install nvidia-driver-455<br></code></pre></td></tr></table></figure><p>如果有使用Apollo的话，也需要安装GPU驱动，最好安装。。</p><p>输入 <code>nvidia-smi</code> 来校验 NVIDIA GPU 驱动是否在正常运行（可能需要在安装后重启系统以使驱动生效）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs text">king@king&gt; nvidia-smi<br>Mon Jan 25 15:51:08 2021<br>+-----------------------------------------------------------------------------+<br>| NVIDIA-SMI 460.27.04    Driver Version: 460.27.04    CUDA Version: 11.2     |<br>|-------------------------------+----------------------+----------------------+<br>| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |<br>| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |<br>|                               |                      |               MIG M. |<br>|===============================+======================+======================|<br>|   0  GeForce RTX 3090    On   | 00000000:65:00.0  On |                  N/A |<br>| 32%   29C    P8    18W / 350W |    682MiB / 24234MiB |      7%      Default |<br>|                               |                      |                  N/A |<br>+-------------------------------+----------------------+----------------------+<br><br>+-----------------------------------------------------------------------------+<br>| Processes:                                                                  |<br>|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |<br>|        ID   ID                                                   Usage      |<br>|=============================================================================|<br>|    0   N/A  N/A      1286      G   /usr/lib/xorg/Xorg                 40MiB |<br>|    0   N/A  N/A      1517      G   /usr/bin/gnome-shell              120MiB |<br>|    0   N/A  N/A      1899      G   /usr/lib/xorg/Xorg                342MiB |<br>|    0   N/A  N/A      2037      G   /usr/bin/gnome-shell               69MiB |<br>|    0   N/A  N/A      4148      G   ...gAAAAAAAAA --shared-files      105MiB |<br>+-----------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>安装完成之后，就可以正式开始安装了。</p><p>下载官方包，官方 <code>Github</code> 链接 <a href="https://github.com/carla-simulator/carla/blob/master/Docs/download.md">https://github.com/carla-simulator/carla/blob/master/Docs/download.md</a> 选择 0.9.13 版本。如下图：</p><p><img src="https://i.imgur.com/SiPAA3b.png" alt="SiPAA3b"></p><p>下载之后解压carla文件夹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"> tar -xzvf CARLA_0<span class="hljs-number">.9</span><span class="hljs-number">.13</span>.tar.gz<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/eydq6q5.jpg" alt="eydq6q5"></p><p>等待之后，解压完毕。然后我们将下载的 <code>AdditionalMaps 放到 </code>carla的import目录下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> cd CARLA_0<span class="hljs-number">.9</span><span class="hljs-number">.13</span>/<br>./ImportAssets.sh<br></code></pre></td></tr></table></figure><p>然后开始配置python环境，关闭防火墙，并添加python的一些库依赖，最绝望的莫过于，网络拒绝链接，</p><p><img src="https://i.imgur.com/ch2nI7W.png" alt="ch2nI7W"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">cd CARLA ./ImportAssets.sh<br></code></pre></td></tr></table></figure><p>即可运行虚拟仿真，此刻感觉显卡已经被拉满。</p><p>除此之外，还有另外一种安装方式，相比较于前面的更加靠谱，但是下载速度较慢可以参考。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sudo apt-get update &amp;&amp;<br>sudo apt-get install wget software-properties-common &amp;&amp;<br>sudo add-apt-repository ppa:ubuntu-toolchain-r/test &amp;&amp;<br>wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - &amp;&amp;<br>sudo apt-add-repository &quot;deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-8 main&quot; &amp;&amp;<br>sudo apt-get update<br>sudo apt-get install build-essential clang-8 lld-8 cmake ninja-build libvulkan1 python python-pip python-dev python3-dev python3-pip libpng-dev libtiff5-dev libjpeg-dev tzdata sed curl unzip autoconf libtool rsync libxml2-dev git<br>sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/lib/llvm-8/bin/clang++ 180 &amp;&amp;<br>sudo update-alternatives --install /usr/bin/clang clang /usr/lib/llvm-8/bin/clang 180<br>Python依赖<br>创建carla python虚拟环境<br>conda create -n carla python=3.7<br>conda activate carla<br>需要提前部署安装conda<br>pip install --user -Iv setuptools==47.3.1 &amp;&amp;<br>pip install --user distro &amp;&amp;<br>pip install --user wheel auditwheel<br>pip install --user pygame numpy<br>下载carla<br>wget https://carla-releases.s3.eu-west-3.amazonaws.com/Linux/Dev/CARLA<span class="hljs-emphasis">_Latest.tar.gz</span><br><span class="hljs-emphasis">mkdir CARLA</span><br><span class="hljs-emphasis">tar -zxvf CARLA_</span>Latest.tar.gz -C CARLA<br>cd CARLA<br>./ImportAssets.sh<br>启动carla服务器<br>cd ../../.. # 回到根目录<br>./CarlaUE4.sh<br>这样服务端就得到了正确的启动<br></code></pre></td></tr></table></figure><p>此时会弹出页面（上帝视角画面）：</p><p>补充一下ubuntu部署安装：下载Anaconda</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.11-Linux-x86<span class="hljs-emphasis">_64.sh</span><br></code></pre></td></tr></table></figure><p>安装Anaconda</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">bash Anaconda3-2021.11-Linux-x86<span class="hljs-emphasis">_64.sh</span><br></code></pre></td></tr></table></figure><p>回车查看许可证，然后q退出许可证，继续回车。</p><h2 id="0x05-侠盗猎车🚗嘟嘟嘟…"><a href="#0x05-侠盗猎车🚗嘟嘟嘟…" class="headerlink" title="0x05 侠盗猎车🚗嘟嘟嘟…"></a>0x05 侠盗猎车🚗嘟嘟嘟…</h2><p><img src="https://i.imgur.com/JQVDrzO.jpg" alt="JQVDrzO"></p><p>这把开的车是救火先锋，嘟嘟嘟嘟嘟！</p><p><img src="https://i.imgur.com/xLxth3H.jpg" alt="xLxth3H"></p><p>CARla的键盘控制命令如下，一个很类似于ROS键盘控制的控制命令，据说还可以与逻辑的方向盘搭配，实现在线侠盗飞车。</p><p><img src="https://i.imgur.com/F8O2UpO.jpg" alt="F8O2UpO"></p><h2 id="0x06-参考资料"><a href="#0x06-参考资料" class="headerlink" title="0x06 参考资料"></a>0x06 参考资料</h2><p><a href="https://www.zhihu.com/people/xie-xiao-fei-78-24/posts">【1】史上最全Carla教程；</a></p><p><a href="https://carla.readthedocs.io/en/latest/start_quickstart/#b-package-installation">【2】Carla官方文档；</a></p><p><a href="https://zhuanlan.zhihu.com/p/447499750">【3】ubuntu 系统安装Carla的docker环境</a>；</p><p><a href="https://www.jianshu.com/p/46e487fbf76c">【4】Carla环境搭建总结</a>；</p><p><a href="https://arijitray1993.github.io/CARLA_tutorial/">【5】Carla教程</a>；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01自动驾驶汽车-使用ROS和Autoware</title>
    <link href="/2022/08/02/01%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6-%E4%BD%BF%E7%94%A8ROS%E5%92%8CAutoware-1/"/>
    <url>/2022/08/02/01%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6-%E4%BD%BF%E7%94%A8ROS%E5%92%8CAutoware-1/</url>
    
    <content type="html"><![CDATA[<h3 id="0x01课程是关于什么的？"><a href="#0x01课程是关于什么的？" class="headerlink" title="0x01课程是关于什么的？"></a>0x01课程是关于什么的？</h3><p>开发生产级自动驾驶系统需要一系列相互关联的技术。本课程将所有重要部分汇集到一个实用的分步指南中，以构建、开发、测试和部署自治系统。</p><p>本中级课程使用流行的开源机器人框架ROS 2 和Autoware.Auto算法，并通过 14 节课程涵盖结合硬件、软件、算法、方法、工具和数据分析。</p><h3 id="0x02我会学到什么？"><a href="#0x02我会学到什么？" class="headerlink" title="0x02我会学到什么？"></a>0x02我会学到什么？</h3><p>您将学习一种现代方法来开发最具创新性的汽车公司正在采用的自动驾驶复杂系统。教师都是经验丰富的专业人士，他们贡献了开源材料，推动行业朝着更高的设计、工程和安全标准迈进。 </p><h3 id="0x03谁应该参加课程？"><a href="#0x03谁应该参加课程？" class="headerlink" title="0x03谁应该参加课程？"></a>0x03谁应该参加课程？</h3><p>这是针对开发预生产自动驾驶系统的个人的中级课程。参与者应具备 C++（包括测试）、机器人框架和系统集成的知识。</p><h3 id="0x04-安装ADE-一个很棒的开发环境"><a href="#0x04-安装ADE-一个很棒的开发环境" class="headerlink" title="0x04 安装ADE(一个很棒的开发环境)"></a>0x04 安装ADE(一个很棒的开发环境)</h3><p>根据官方的描述，ADE是一个很棒的开发环境，它试图从基础镜像创建一个 Docker 容器，并在<code>/opt</code>. 基础映像提供开发工具（例如 vim、udpreplay 等），卷提供额外的开发工具（例如 IDE、大型第三方库）或已发布的软件版本（例如最新的 AutowareAuto 版本）。此外，ADE 可以在图像和卷的版本之间轻松切换。</p><p>以下为ADE示例：</p><p><img src="https://i.imgur.com/lfPa4R9.png" alt="lfPa4R9"></p><p>安装ADE要求提前配置好Docker，如果没有配置或者出错的话，很可能会遇到第一个致命问题。</p><p><img src="https://i.imgur.com/wQdgyIO.jpg" alt="wQdgyIO"></p><p>解决办法：看起来您的用户不在 docker 组中。您可能需要这样做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -aG docker $USER<br></code></pre></td></tr></table></figure><p>注销并重新登录，以便重新评估您的组成员身份。</p><p>提供一篇参考文章[1]解决这个问题。<a href="https://codeantenna.com/a/76wmTrqsGY">https://codeantenna.com/a/76wmTrqsGY</a></p><p>另外因为不同机器架构的不同， 很容易导致因为架构依赖出问题，所以这里我贴上aarch（也就是arm架构）和x86_64包的地址。详见参考链接[2]<a href="https://gitlab.com/ApexAI/ade-cli/-/releases">https://gitlab.com/ApexAI/ade-cli/-/releases</a></p><p>接着便是官方提供的安装 ADE步骤：值得注意的是ade+x86_64因不同架构需要更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;HOME&#125;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> adehome</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> adehome</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://gitlab.com/ApexAI/ade-cli/uploads/85a5af81339fe55555ee412f9a3a734b/ade+x86_64</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> ade+x86_64 ade</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x ade</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> ade ~/.local/bin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">which</span> ade</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Update ade</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ade update-cli</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Now setup ade</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> .adehome</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --recurse-submodules https://gitlab.com/autowarefoundation/autoware.auto/AutowareAuto.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> AutowareAuto/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ade start</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">this will take awhile</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ade enter</span><br></code></pre></td></tr></table></figure><p>执行到这一步的时候（ade start），大概率会因为架构的问题再次出现一次问题。选择自己配置架构需要选择的配置项，然后start开始安装。</p><p><img src="https://i.imgur.com/KZsgBNG.png" alt="KZsgBNG"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Apollo 自动驾驶虚拟仿真赛参赛笔记</title>
    <link href="/2022/06/08/Apollo%20%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E8%99%9A%E6%8B%9F%E4%BB%BF%E7%9C%9F%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/08/Apollo%20%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E8%99%9A%E6%8B%9F%E4%BB%BF%E7%9C%9F%E8%B5%9B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-比赛情况"><a href="#0x01-比赛情况" class="headerlink" title="0x01 比赛情况"></a>0x01 比赛情况</h2><p>​六月的一天，刚参加完市区创业比赛以及连续二面某科创学院完成这些事情之后，终于可以腾出手来学习一下Apollo，提起Apollo其实一直都是我想学习的领域，因为在读大一的时候，和小伙伴们系统的学习了ROS机器人操作系统，这两年用着ROS也参加了很多的比赛，也在多个全国性的比赛中获得了比较好的名次。恰巧，学院的老师参加了Apollo的线上师资培训会，我也跟着老师学习了一下，所以就来参加一下自动驾驶虚拟仿真赛。目前的话我们学校所在的赛区还没有开赛，但是我自己学到了虚拟联合仿真，有参考大佬的视频，也有自己摸索的过程。本文章不会涉及任何解题说明及答案分享，结合群内目前公开的信息进行记录。比赛完毕后会更新此文章内容进行记录。</p><span id="more"></span><h2 id="0x02-赛题情况"><a href="#0x02-赛题情况" class="headerlink" title="0x02 赛题情况"></a>0x02 赛题情况</h2><p>有些题目不需要改进就直接有得分，例如红路灯这道题。如果精益求精的话可以进行改正……</p><table><thead><tr><th>人行道避让</th><th>主车向前行驶，前方遇到有人通过人行道，主车需要停止在人行道前5m～5.5m内停车</th></tr></thead><tbody><tr><td>评判标准</td><td>主车未停止在人行道前5～5.5m内，本场景分扣20分，若未避让行人或超出停止线停车，本场景计0分</td></tr></tbody></table><p>​这道题的要求是要在5—5.5范围之内，先来看下我的成绩。</p><p><img src="https://i.imgur.com/LWdbVeT.png" alt="LWdbVeT"></p><p>​虚拟测评的成绩是80分（看来有些参数确实还得调一调)。这道题解题的时候需要注意一下量距离。因为题目要求的距离是要在5-5.5m之间，超出就会扣分。</p><p><img src="https://i.imgur.com/Tin6X05.png" alt="Tin6X05"></p><p>​意思就是如此，可以测出来双向的距离，然后进行修改即可。要说的是，最开始的坐标轴位置不太会看，因为给的是经纬度，所以比较懵，最后发现经纬度给的是鼠标的经纬度，通过这个就可以测出在哪里停车，哪里的位置是5m，然后修改参数调参就可以。解法可以参考网络的解法，但是参数需要根据经纬度自己调，这个也没办法分享，大家自己测试即可。</p><table><thead><tr><th>障碍物绕行</th><th>主车行驶过程中，前方监测到静态障碍物后借道绕行。距离目标障碍物横向距离至少保持 1 米，借道避障限速不得超过 5 m&#x2F;s</th></tr></thead><tbody><tr><td>评分标准</td><td>主车与目标障碍物横向距离少于1米，本场景分扣5分；借道避障中心点限速超过5 m&#x2F;s，本场景分扣5分。</td></tr></tbody></table><p>​障碍物绕行这道题本身官方给的手册里面就已经包含了本道题的重要参数讲解和具体的解题思维，所以在这里不多阐述。具体参考大赛资料：[ 使用 Sim_Control 仿真调试 PnC 模块.pdf]</p><table><thead><tr><th>减速带通行</th><th>主车在通过减速带时速度不超过 3 m&#x2F;s。</th></tr></thead><tbody><tr><td>评判标准</td><td>主车在通过减速带时速度每超速1m&#x2F;s，扣20分,超过5m&#x2F;s,本场景计0分。</td></tr></tbody></table><p>​这道题的主要场景要求是车辆在经过减速带时候，速度不能超过3m&#x2F;s，需要换算成km&#x2F;h，因为我们在dream viewer里面看到的是车辆的实际速度。所以进行换算。1 米&#x2F;秒(m&#x2F;s)&#x3D;3.6 千米&#x2F;时(km&#x2F;h)，要求不能超过3m&#x2F;s即不能超过10.8km&#x2F;h，因此进行调试，最终把车速控制在10km&#x2F;h，通过本道题评测，但是因为一些其他的原因（我也不知道什么原因），这道题的评分只有80分。</p><p><img src="https://i.imgur.com/loNj9Z1.png" alt="loNj9Z1"></p><p>测评结果是这样，但是分数只有80分，可能还需要调整相关的参数，重新build。</p><p><img src="https://i.imgur.com/XQYHEnq.png" alt="XQYHEnq"></p><p>继续更新，减速带这道题，做出来的分值只有80分，于是乎重新看了看代码，换了另外一个思路去做。首先需要在Planning模块下进行代码添加，设置减速带限速为总速度的20%，其次再去参考线代码中添加参考线的启动点，添加完成进行patch包大包，然后在进行仿真测试。</p><p><img src="https://i.imgur.com/e7YGMVN.png" alt="e7YGMVN"></p><p>最终成功获得高分成绩。</p><p><img src="https://i.imgur.com/L9UxT4q.png" alt="L9UxT4q"></p><p>未完待续。。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>智能网联汽车漏洞挖掘赛无线题WP</title>
    <link href="/2022/04/30/%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9B%E6%97%A0%E7%BA%BF%E9%A2%98WP/"/>
    <url>/2022/04/30/%E6%99%BA%E8%83%BD%E7%BD%91%E8%81%94%E6%B1%BD%E8%BD%A6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%B5%9B%E6%97%A0%E7%BA%BF%E9%A2%98WP/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-题目1-wav格式的故事1"><a href="#0x01-题目1-wav格式的故事1" class="headerlink" title="0x01 题目1:wav格式的故事1"></a>0x01 题目1:wav格式的故事1</h2><p>描述：一般WAV是用来给车机放歌的，试试有没有flag，flag为小写md5 附件下载地址：<br>下载后看到是一个wav文件，用urh打开分析。</p><span id="more"></span><p><img src="https://i.imgur.com/Hci9Rjx.png" alt="Hci9Rjx"></p><p>解调之后查看AC码直接出Flag</p><h2 id="0x02-题目2-wav格式的故事2"><a href="#0x02-题目2-wav格式的故事2" class="headerlink" title="0x02 题目2:wav格式的故事2"></a>0x02 题目2:wav格式的故事2</h2><p>描述：一般WAV是用来给车机放歌的，试试有没有flag，flag为小写md5 附件下载地址：<br>下载之后用urh打开，发现解调后并没有什么实际的信号和信息。播放一次猜测是莫斯密码，手动数莫斯密码。</p><p><img src="https://i.imgur.com/Yc6VdBY.png"></p><p>按照信号的粗细不同，以摩斯密码进行猜解。（。。。。。。</p><p><img src="https://i.imgur.com/Uq03QlR.png" alt="Uq03QlR"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ble_CTF</title>
    <link href="/2022/03/30/Ble-CTF/"/>
    <url>/2022/03/30/Ble-CTF/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-Ble夺旗"><a href="#0x01-Ble夺旗" class="headerlink" title="0x01 Ble夺旗"></a>0x01 Ble夺旗</h2><p>BLE CTF 的目的是教授蓝牙低功耗客户端和服务器交互的核心概念。虽然它的构建也很有趣，但它的构建目的是教授和强化进入蓝牙黑客世界所需的核心概念。完成此 CTF 后，您应该拥有开始摆弄您能找到的任何 BLE GATT 设备所需的一切。</p><span id="more"></span><h2 id="0x02-Bluetooth设备烧录"><a href="#0x02-Bluetooth设备烧录" class="headerlink" title="0x02 Bluetooth设备烧录"></a>0x02 Bluetooth设备烧录</h2><p>首先，您需要一个 esp32 微控制器。</p><p>将此项目固件刷新到 ESP32 的最简单方法是刷新提供的预编译二进制文件。您将需要安装<a href="https://github.com/espressif/esptool">esptool</a> 然后执行以下操作： 克隆存储库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/hackgnar/</span>ble_ctf<br></code></pre></td></tr></table></figure><p>将目录更改为存储库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ble_ctf<br></code></pre></td></tr></table></figure><p>闪存预编译的二进制文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">esptool<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--chip</span> esp32 <span class="hljs-attr">--port</span> /dev/ttyUSB0 \<br><span class="hljs-attr">--baud</span> <span class="hljs-number">115200</span> <span class="hljs-attr">--before</span> default_reset <span class="hljs-attr">--after</span> hard_reset write_flash \<br>-z <span class="hljs-attr">--flash_mode</span> dio <span class="hljs-attr">--flash_freq</span> <span class="hljs-number">40</span>m <span class="hljs-attr">--flash_size</span> detect \<br><span class="hljs-number">0</span>x1000 build/bootloader/bootloader<span class="hljs-selector-class">.bin</span> \<br><span class="hljs-number">0</span>x10000 build/gatt_server_service_table_demo<span class="hljs-selector-class">.bin</span> \<br><span class="hljs-number">0</span>x8000 build/partitions_singleapp.bin<br></code></pre></td></tr></table></figure><p> 编译成功，上电后即可使用ESP32进行低功耗蓝牙挑战。</p><p>挑战系统采用树莓派，因为树莓派系统自身所带的蓝牙适配器适合进行操作，且无需购买其他设备即可进行挑战。因此首先推荐树莓派进行使用。</p><p>夺旗内容可以等待我后续探索后更新，也可以直接参考看雪文章。</p><h2 id="0x03-参考文章"><a href="#0x03-参考文章" class="headerlink" title="0x03 参考文章"></a>0x03 参考文章</h2><p><a href="https://bbs.pediy.com/thread-271543.htm">https://bbs.pediy.com/thread-271543.htm</a></p><p><a href="https://github.com/hackgnar/ble_ctf/blob/master/docs/setup.md">https://github.com/hackgnar/ble_ctf/blob/master/docs/setup.md</a></p><p><a href="https://github.com/hackgnar/ble_ctf">https://github.com/hackgnar/ble_ctf</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Raspberry</title>
    <link href="/2022/03/29/Raspberry/"/>
    <url>/2022/03/29/Raspberry/</url>
    
    <content type="html"><![CDATA[<p>树莓派镜像烧录用到的一些工具和镜像下载地址。</p><span id="more"></span><h2 id="0x01-镜像下载"><a href="#0x01-镜像下载" class="headerlink" title="0x01 镜像下载"></a>0x01 镜像下载</h2><p>Ubuntu mate 镜像下载：<a href="https://ubuntu-mate.org/download/arm64/focal/thanks/?method=magnet">https://ubuntu-mate.org/download/arm64/focal/thanks/?method=magnet</a></p><h2 id="0x02-工具下载"><a href="#0x02-工具下载" class="headerlink" title="0x02 工具下载"></a>0x02 工具下载</h2><p>树莓派官方烧录工具 ：<a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a></p><p>格式化工具下载：<a href="https://www.sdcard.org/">https://www.sdcard.org/</a></p><p>免去了每次下载时候都要找半天，质量层次不齐。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅浅研究滚动码(上)</title>
    <link href="/2022/03/24/%E6%B5%85%E6%B5%85%E7%A0%94%E7%A9%B6%E6%BB%9A%E5%8A%A8%E7%A0%81(%E4%B8%8A)/"/>
    <url>/2022/03/24/%E6%B5%85%E6%B5%85%E7%A0%94%E7%A9%B6%E6%BB%9A%E5%8A%A8%E7%A0%81(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-Keeloq算法介绍"><a href="#0x01-Keeloq算法介绍" class="headerlink" title="0x01 Keeloq算法介绍"></a>0x01 Keeloq算法介绍</h2><p> KeeLoq算法的核心思想就是用8byte密钥加密4byte明文，从而得到4byte密文或者用8byte密钥解密4byte密文，还原出原4byte明文。KeeLoq算法演算过程需要定义一个数据寄存器，用于存放4byte明文y31<del>0或者4byte密文y31</del>0，和一个密钥寄存器，用于存放8byte密钥k63~0。</p><p>对于系统工作原理而言，门禁系统应该是先进社会最为常见的系统。车库门禁系统的目的是实现遥控无匙门禁技术 (R KE) ,使驾驶员可以通过遥控器的按钮来开关库门 , 下图为其原理结构图。系统由遥控编码器及接收解码 器组成。其中遥控器由编码芯片、发射电路组成 ,附加 按键及电池 ,是袖珍发射装置 ,可随身携带 ;接收器由接 收电路、解码芯片、控制电路及执行机构组成 ,执行机构又包括门控电机、声光报警等。下面分析系统各部分的设计及应用。 </p><p><img src="https://i.imgur.com/dw12BZF.png" alt="dw12BZF"></p><p>KeeLoq数据加密过程模型图下图所示，首先定义一个非线性表，这个非线性表有5bits输入码，1bit输出码。它在数据寄存器中间隔均匀地取5bits: y31、y26、y20、y9、y1，通过NLF（Nonlinear Logic Function）运算产生一个输出码。输出码再与数据寄存器中的y16与y0以及密钥寄存器中的k0进行异或运算后生成1bit加密数据码。每生成1bit加密数据码，密钥寄存器和数据寄存器分别进行移位，密钥寄存器作循环移位，加密数据码作为数据寄存器移位的输入，重复上述步骤528次后，得到4byte的输出密文。</p><p>NLF(x4,x3,x2,x1,x0)&#x3D;x4x3x2^x4x3x1^x4x2x0^x4x1x0^x4x2^x4x0^x3x2^x3x0^x2x1^x1x0^x1^x0</p><p><img src="https://i.imgur.com/kHWsrin.png" alt="kHWsrin"></p><p>针对于Keeloq算法研究部分，本文部分内容来自多篇学术论文，站在巨人的肩膀上，能够走的更远，致敬前辈。</p><p>我们先来看看HCS系列芯片，HCS系列芯片是美国Microchip公司推出的芯片，是为远程无“钥匙”系统中加密识别但愿而设计的KEELOQ滚动码编码解码器，它采用Keeloq滚动码算法对所要传输的代码进行加密。</p><p>这里是拿到的全网公开的一些芯片信息。有了这些介绍之后，我们就可以大致去研究滚动码的加密了。</p><p><img src="https://i.imgur.com/bpSHdH8.png" alt="bpSHdH8"></p><p>可以看到主要的长度大概是67-69bit，对比数据格式来看，大同小异。</p><p>就加密方法来说，这里找一张很简洁的图来说明。</p><p><img src="https://i.imgur.com/vTTWXHi.png" alt="vTTWXHi"></p><p>可以看到主要是有几个数据比较重要，32bit的序列号，64bit的编码密钥，16bit的同步计数值，除此之外还有识别码，功能码等等。</p><ul><li>同步计数值顾名思义就是用来同步计数的每次判断信号合法后汽车执行对应功能并将同步计数值保存下来，当新的信号到来会对比汽车保存的同步计数值，如果小于或者等于将判断信号非法，不执行任何操作，当大于保存的同步计数值，汽车执行对应功能并将同步计数值保存下来。</li><li>功能码顾名思义就是代码执行什么功能的码</li></ul><p>直接看这张图可能会是比较云里雾里。下面我们来看有关于Keeloq编码密钥的算法，这样的话才能更加清晰的明白此算法加密的原理。</p><h2 id="0x02-简单加密"><a href="#0x02-简单加密" class="headerlink" title="0x02 简单加密"></a>0x02 简单加密</h2><ul><li>直接把厂商密钥当作编码密钥的方式</li></ul><p><img src="https://i.imgur.com/0QLuLrx.png" alt="0QLuLrx"></p><h2 id="0x03-标准密钥加密"><a href="#0x03-标准密钥加密" class="headerlink" title="0x03 标准密钥加密"></a>0x03 标准密钥加密</h2><ul><li><p><strong>标准秘钥</strong>生成算法假设序列号为<strong>0x1234567</strong>，通过标准的秘钥生成算法来定的话，首先会拿</p><p><img src="https://i.imgur.com/OeQfq9E.png" alt="OeQfq9E"></p></li></ul><p><img src="https://i.imgur.com/h8c1GIY.png" alt="h8c1GIY"></p><h2 id="0x04-安全加密"><a href="#0x04-安全加密" class="headerlink" title="0x04 安全加密"></a>0x04 安全加密</h2><p><img src="https://i.imgur.com/W0iD33D.png" alt="W0iD33D"></p><h2 id="0x05-三种区别"><a href="#0x05-三种区别" class="headerlink" title="0x05 三种区别"></a>0x05 三种区别</h2><ul><li>简单加密直接拿厂商秘钥加密的话，直接可以对其他的设备进行解密操作。</li><li>标准秘钥生成算法，因为每个遥控序列号都是不同的所以生出来的秘钥也是不同的。如果能获取到编码秘钥就是只对这个设备有用然而对其他的设备都没有效果的，但是如果厂商秘钥被其他人获取了，因为发送信号时候会带着28Bit的序列号，所以只要别人拿到了这个厂商秘钥就能解密信号。</li><li>安全秘钥生成算法就不同了，即使是厂商秘钥被别人知道了，也只能拿到前32位秘钥，后32位是根据种子码生成的，而种子码又是随机生成的，相比较前两种加密算法来说，安全密钥生成算法是较为安全的一种算法。</li></ul><p>最后附加密密钥产生原理图和滚动编码产生原理图。</p><p><img src="https://i.imgur.com/vwsG0bP.png" alt="vwsG0bP"></p><h2 id="0x06-参考文章"><a href="#0x06-参考文章" class="headerlink" title="0x06 参考文章"></a>0x06 参考文章</h2><p>[1]使用 HackCube-Special 分析滚动码信号-360无线电安全研究院</p><p>[2]基于KEELOQ技术的车库门禁系统</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ros2 Install</title>
    <link href="/2022/03/19/ros2/"/>
    <url>/2022/03/19/ros2/</url>
    
    <content type="html"><![CDATA[<h2 id="ROS2的基本概念"><a href="#ROS2的基本概念" class="headerlink" title="ROS2的基本概念"></a>ROS2的基本概念</h2><p>ROS是一个用于在不同进程间匿名的发布、订阅、传递信息的中间件。 ROS2系统的核心部分是ROS网络(ROS Graph)。ROS网络是指在ROS系统中不同的节点间相互通信的连接关系。 ROS Graph这里翻译成了ROS网络，因为我觉得Graph更加抽象，而网络的概念更容易帮助理解其内涵。</p><span id="more"></span><p>ROS2 是新一代机器人操作系统。2020年6月5日，ROS2 的最新版本 <code>Foxy Fitzroy</code> 正式发布了， 支持到2023年的3月。</p><h2 id="ROS2-支持的平台"><a href="#ROS2-支持的平台" class="headerlink" title="ROS2 支持的平台"></a>ROS2 支持的平台</h2><ul><li>Linux (Ubuntu Focal(20.04))</li><li>macOS</li><li>Windows</li></ul><h2 id="Install-ROS2"><a href="#Install-ROS2" class="headerlink" title="Install ROS2"></a>Install ROS2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">更换语言<br>sudo locale-gen en_US en_US.UTF-8<br>sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8<br><span class="hljs-built_in">export</span> LANG=en_US.UTF-8<br></code></pre></td></tr></table></figure><h2 id="添加ROS2源"><a href="#添加ROS2源" class="headerlink" title="添加ROS2源"></a>添加ROS2源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install curl gnupg2 lsb-release<br>curl http://repo.ros2.org/repos.key | sudo apt-key add - <br>sudo sh -c <span class="hljs-string">&#x27;echo &quot;deb http://packages.ros.org/ros2/ubuntu `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><h2 id="安装ROS2桌面版"><a href="#安装ROS2桌面版" class="headerlink" title="安装ROS2桌面版"></a>安装ROS2桌面版</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install ros-foxy-desktop <br></code></pre></td></tr></table></figure><h2 id="卸载ROS2"><a href="#卸载ROS2" class="headerlink" title="卸载ROS2"></a>卸载ROS2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt remove ros-foxy-*<br>sudo apt autoremove <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Manchester(逆向拨码器拨码数据)</title>
    <link href="/2022/03/18/Manchester/"/>
    <url>/2022/03/18/Manchester/</url>
    
    <content type="html"><![CDATA[<p>大家好，我是橡树，今天给大家带来有关无线遥控信号逆向分析的文章。当今社会，电子产品大量依靠各种无线传输技术，无线通信技术上的传输、认证、加密等安全问题，在各种设备对无线技术依赖加深的情况下变得越来越重要。无线安全的研究领域非常的宽泛，随着越来越多的物联网控制设备采用无线遥控信号，无线安全方面的研究也逐渐被更多的网络安全研究员所关注。本文结合作者在无线安全领域做出的一些实例侦听和逆向分析，希望能够抛砖引玉为无线安全研究做出贡献，同时对于研究过程中的遇到的一些问题希望可以得到解答。</p><span id="more"></span><h1 id="0x01-信号101"><a href="#0x01-信号101" class="headerlink" title="0x01 信号101"></a>0x01 信号101</h1><p>要研究一个无线遥控器，首先我们需要先了解该无线遥控信号一般工作所在的ISM频段，例如汽车无线钥匙和电动自行车的工作频段通常是在315Mhz或433Mhz传输数据。如果是无钥匙启动系统则多会采用123Mhz或者13.56Mhz的RFID技术。车库卷闸门遥控信号一般工作频段是在315 Mhz，除此之外还有车库收费挡杆的遥控信号频段都大多是工作在433 Mhz或315Mhz频段。诸如门禁卡、无线钥匙、无线遥控器、手机、汽车等只要使用了无线介质进行数据交互，那么这条无线链路就有可能被监听、解密、重放、劫持甚至被入侵控制。<br>当无线遥控钥匙在发了一串0和1之后，需要正确的调制及编码方式，收发双方才可以进行交互，通常信号的调制方面主要以OOK&#x2F;ASK&#x2F;FSK为主，这几种调制方案的应用非常广泛，其中OOK调制方案是最简单的，仅仅需要将载波信号发送到功放和天线。当这些信号被别有用心的人捕获或者破解，后果是无法想象的。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/7uLFjH.png" alt="7uLFjH"></p><p>(ASK信号在频谱上的现象)</p><h1 id="0x02-软件无线电"><a href="#0x02-软件无线电" class="headerlink" title="0x02 软件无线电"></a>0x02 软件无线电</h1><p><em>软件无线电，即Software Defined Radio(SDR)，有时也成为Software Radio</em><br>由于软件无线电具有能够快速开发、迭代更新的特点，所以它特别适合用在一些定制化的应用中。例如学生和研究人员用它来处理无线信号。产品开发类的人员用它开发设备。高校内的通信教学活动以及业余无线电爱好者的学习和使用。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/RnfXUM.png" alt="RnfXUM"></p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/ywzvGm.png" alt="ywzvGm"></p><p>无线信号安全的研究必然离不开相关硬件的支持，在这里我将研究所用到的软硬件工具及SDR平台进行简单介绍。</p><h1 id="0x03-无线安全研究工具"><a href="#0x03-无线安全研究工具" class="headerlink" title="0x03 无线安全研究工具"></a>0x03 无线安全研究工具</h1><p>Pluto-SDR: Pluto-SDR由亚德诺半导体出品，整体设计方案是AD9363射频收发器+ZYNQ7010FPGA。AD9363的收发频率为325 MHz至3.8 GHz，支持时分双工(TDD)和频分双工(FDD)工作模式，AD&#x2F;DA为12bit性能优于HackRF One。Pluto-SDR可在多个平台上使用，例如GNURADIO和MATLAB平台，可以实现基础的无线信号收发和无线信号安全的实验。以下数据表是各种常见SDR硬件之间的对比。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/uqV0tT.png" alt="uqV0tT"></p><p><em>（几种SDR的对比-图片来源网络）</em><br><em>RTL-SDR: 一个低廉的家用消费档次的 DVB-T USB 接口的接收机的创新发明，也是最为廉价的软件无线电接收平台。</em><br><em>CC1101: 美国TI公司出品的工作在低于1GHz频段的无线数传芯片,一款低于1GHz设计旨在用于极低功耗RF应用。其主要针对工业、科研和医疗(ISM)以及短距离无线通信设备(SRD)</em><br>Raspberry Pi: 只有信用卡大小的微型电脑，其系统基于Linux，树莓派可作为电台进行信号接收，在可控的范围之内，采用杜邦线即可实现基础的实验效果。<br>RTL-433: rtl_433 (despite the name) is a generic data receiver, mainly for the 433.92 MHz, 868 MHz (SRD), 315 MHz, 345 MHz, and 915 MHz ISM bands.It works with RTL-SDR and&#x2F;or SoapySDR. Actively tested and supported are Realtek RTL2832 based DVB dongles (using RTL-SDR) and LimeSDR (LimeSDR USB and LimeSDR mini engineering samples kindly provided by MyriadRf), PlutoSDR, HackRF One (using SoapySDR drivers), as well as SoapyRemote. —来自官方解释</p><p>有了这些软硬件设备的支持和协调之下，使得我们的安全研究有了更近一步的突破，在这里要感谢学院的科创团队为我们研究团队提供的设备支持和资金使得我们可以更加清晰的完成无线信号的基础研究。</p><h1 id="0x03-无线信号捕获与解调"><a href="#0x03-无线信号捕获与解调" class="headerlink" title="0x03 无线信号捕获与解调"></a>0x03 无线信号捕获与解调</h1><p>普通的固定码遥控器中最为常见的是四键遥控器。在此系统中，主机依靠无线配件的地址信号，通俗来讲就是一组数字编号用来区分不同的无线配件。如果两个无线配件的地址相同，主机就把它们当作是同一个无线配件。在四键遥控器中，一般有8位地址可以由用户设置，每位地址可以选择3种状态0、1或者悬空。这样在不重复的情况下，总共就可以有3的8次方，也就是6561个地址。在进行自动对码的时候，主机收到这些信息会和以前加入的配件信息进行比较，如果地址是以前对码时候加入过的，主机就接受这个遥控器的指令，否则主机不会对于这个遥控器有任何的响应。所以在实验开始之前，我们首先要做的就是去捕获设备的无线信号码。大致有以下几种方法可以供我们去捕获设备的无线信号工作频段。<br>第一种方法，也是最为简单的方法是直接拆开要捕获信号的发射设备，查询其FCC ID或CMIIT ID信息，该类网站上收录有其硬件的发射功率，发射频谱等信息资料，可以通过检索其资料对于无线信号工作频段进行了解，进而捕获目标发射设备的信号。在URH的教学案例视频中作者也有提到如何去具体的查询FCC ID以及拿到FCC ID之后具体如何去查看更为详细的硬件信息。<br>第二种方法是直接使用软件无线电设备，频谱分析软件如GQRX等设备，在较大的频谱范围之内连续触发要捕获信号的发射设备，使其不断向外发出信号，大致判断其工作范围，然后在进行验证，获得设备最终的无线信号工作频谱频段。<br>以下为使用第二种方法获得要捕获信号的发射设备的无线信号工作频段图:</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/8IylEZ.png" alt="8IylEZ"></p><p>（无线门铃信号工作频谱）</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/goFjS2.png" alt="goFjS2"></p><p>（无线门铃信号频谱图）<br>在获取到发射设备的无线信号工作频谱之后，就可以对于其信号进行录制和逆向分析。<br>如上即为录制的普通无线门铃信号，对其进行解调后即可将其信号转换为01表示的数字信号或者转化为HEX码，一般来讲直接观察HEX码是更容易使我们逆向信号的数据，然后对于该数字信号进行记录。<br>然而人工观察的方法容易出错(尤其是通过01去判断信号信息)，在这里我会更加的依赖软件的分析，接下来我们将我们捕获的信号进行信号逆向分析，试图将其从无线电信号转化为数字信号。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/fShsuC.png" alt="fShsuC"></p><p>（自动解调-失败）</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/L2tSru.png" alt="L2tSru"></p><p>（手动解调-成功）<br>我们可以看到使用软件自动解调之后显示的数据信号并非我们实际在频谱中可以看到的数字信号。但是我们知道了默认选择的是ASK的解调方式，所以我们针对于该解调方式进行一些其他的操作。更换本地采样率继续进行解调，发现解调成功，成功逆向出该遥控信号的数字信号。然后通过CC1101，树莓派或者Pluto SDR设备对于该信号进行测试，观察门铃接收端是否有相应的响应，有响应反馈即代表信号逆向成功。<br>下面我们针对于四键遥控器的设计过程及原理图进行具体的分析：</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/bz10Xo.png" alt="bz10Xo"></p><p>(拨码遥控器)</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/2aVaro.png" alt="2aVaro"></p><p>（类似的原理图）<br>由于此拨码遥控器买来时候并未配套有相关的电路说明文档，因此我在研究清楚之后寻找了一个类似的电路图供大家参考。先看左边的1-8个键码，对应右图中的A0-A7。除此之外，还配备有四个微动开关。分别为S1、S2、S3、S4。在进行测试的时候，首先将8个拨码器全部下拉到底。此时通过RTL-433得到的信息是FF FF FC 80，转换为01二进制为：11111111 11111111 11111100 1。此时在重新拨号，最后的知，80为默认结尾，可以直接忽略。因为不管每次怎么拨，按哪个微动开关，最终都为80，前面的FC代表的是四个微动开关中的一个微动开关。FF FF 即为拨码器可以改变的值。又因为其本身包含三种状态，要么是00(下拉) 要么是11(上拉)，要么是10(中间悬空)，很轻松我们就完全逆向了此拨码遥控器。</p><h1 id="0x04-无线遥控信号的物联网化-引申概念"><a href="#0x04-无线遥控信号的物联网化-引申概念" class="headerlink" title="0x04 无线遥控信号的物联网化(引申概念)"></a>0x04 无线遥控信号的物联网化(引申概念)</h1><p>进行了上面的一些实验之后，我们思考如何将收到的无线遥控信号发送到更远端的距离并且将其保存。如果可能更希望其可以在物联网平台上被逆向分析。于是为了解决以上的问题我们进行实验尝试。Home Assistant 是一款基于 Python 的智能家居开源系统，支持众多品牌的智能家居设备，可以轻松实现设备的语音控制、自动化等。因为Home Assistant 非常容易部署，所以我们便决定采用Home Assistant 的物联网方案将无线遥控信号物联网化。除此之外，我们还需要应用到MQTT进行远距离通信。便于将我们在本地捕获到的无线遥控信号解码后上传到我们的MQTT服务器，最终和我们的Home Assistant智能家居平台进行通信，实现无线遥控信号在被捕获之后保存和传输到更远的地方。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/1qIGG2.png" alt="1qIGG2"></p><p>（Home Assistant Logo）</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/62LuE8.png" alt="62LuE8"></p><p>（MQTT监听解码数据）<br>首先我们需要安装Home Assistant，这里我使用的是树莓派安装Home Assistant 的方式，因为rtl-433程序也是运行在树莓派上的,将树莓派安装好Home Assistant之后也便于我们进行端口映射和转发。这张图是在树莓派上安装Home Assistant的不同方式:</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/J5IQSW.png" alt="J5IQSW"></p><p>其中Hassbian没有图形界面，详见：<a href="https://www.home-assistant.io/blog/2019/10/26/rip-hassbian/">https://www.home-assistant.io/blog/2019/10/26/rip-hassbian/</a><br>Mossbian是由Hassbian改版的版本，详情：<a href="https://home-assistant.cc/mossbian/">https://home-assistant.cc/mossbian/</a> 目前已停止维护，遂放弃这两种方案。直接在树莓派的系统Raspbian上通过手动的方式安装Home Assistant。<br>具体安装参考链接:<a href="https://comhome-assistant.cc/installation/raspberrypi/raspbian/">https://comhome-assistant.cc/installation/raspberrypi/raspbian/</a><br>安装完成之后我们便可以从局域网内任意终端浏览器访问 <a href="http://raspberry/">http://Raspberry</a> IP :8123，进入 Home Asssitant。<br>物联网平台安装完毕之后，我们还需要安装MQTT服务器，之前参加物联网相关的比赛，华为云社区为我们提供了云服务器的代金券，因此我们便使用华为云的服务器去搭建MQTT服务器，让我们捕获到的遥控信号通过MQTT传输到云平台进而传输到我们的物联网平台上。<br>MQTT（Message Queuing Telemetry Transport）消息队列遥测传输协议，是一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的”轻量级”通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布。<br>MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。<br>了解了MQTT之后，我们决定在云服务器上部署Eclipse Mosquitto进行MQTT协议之间的一些通信。Eclipse Mosquitto是一个开源消息代理，实现了MQTT协议版本3.1和3.1.1。Mosquitto轻量，适用于低功耗单板计算机到完整服务器的所有设备。Mosquitto项目还提供了用于实现MQTT客户端的C库以及非常受欢迎的mosquitto_pub和mosquitto_sub命令行MQTT客户端。Mosquitto是用C语言实现MQTT协议的Broker。是一款实现了消息推送协议 MQTT v3.1 的开源消息代理软件，提供轻量级的，支持可发布&#x2F;可订阅的的消息推送模式，使设备对设备之间的短消息通信变得简单，比如现在应用广泛的低功耗传感器，手机、嵌入式计算机、微型控制器等移动设备。一个典型的应用案例就是 Andy Stanford-ClarkMosquitto(MQTT协议创始人之一)在家中实现的远程监控和自动化。<br>我们也对于其进行安装。成功安装Mosquitto后MQTT通信的测试。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/P3pGMT.png" alt="P3pGMT"></p><p>（MQTT通信测试）<br>在搭建完成了上述的实验环境之后，我们将对于我们的想法进行验证，让我们在本地通过软件无线电设备捕获到的设备信号通过MQTT协议传输到我们的MQTT服务器上，进而将数据转发到物联网平台上，在物联网平台上对于该Publish进行监听，最终获取到从远端传输而来解码好的无线遥控信号。</p><p><img src="https://gitee.com/Theodorea/oss/raw/master/uPic/aWl350.png" alt="aWl350"></p><p>（MQTT实时接收到的已解码数据）<br>具体实现视频链接<br>【MQTT实时接收已解码数据-哔哩哔哩】 <a href="https://b23.tv/edY1XoO">https://b23.tv/edY1XoO</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
